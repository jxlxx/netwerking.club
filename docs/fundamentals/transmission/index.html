<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Transmission # Encoding # First of all, the physical layer transmits signals, not bits. So we need to translate back and forth. This is done via modulation and demodulation.
Clock recovery # Clock recovery means being able to recover and deduce the senders clock, since the sender sends information triggered by clock cycles.
Intuitively, clock recovery is easier by sending frequent 0-1 and 1-0 transmissions.
Scheme 1 - NRZ # The simplest scheme."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Transmission"><meta property="og:description" content="Transmission # Encoding # First of all, the physical layer transmits signals, not bits. So we need to translate back and forth. This is done via modulation and demodulation.
Clock recovery # Clock recovery means being able to recover and deduce the senders clock, since the sender sends information triggered by clock cycles.
Intuitively, clock recovery is easier by sending frequent 0-1 and 1-0 transmissions.
Scheme 1 - NRZ # The simplest scheme."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/docs/fundamentals/transmission/"><meta property="article:section" content="docs"><title>Transmission | Computer Networking</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.5a9b9c87a2ff718b2b0ff51fe9e0f18ce5a3b0e8487a05d677f8a0330df9477e.js integrity="sha256-Wpuch6L/cYsrD/Uf6eDxjOWjsOhIegXWd/igMw35R34=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Computer Networking</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/fundamentals/>Fundamentals</a><ul><li><a href=/docs/fundamentals/transmission/ class=active>Transmission</a></li><li><a href=/docs/fundamentals/switches-links-bridges/>Switches, Links, & Bridges</a></li><li><a href=/docs/fundamentals/ethernet/>Ethernet</a></li><li><a href=/docs/fundamentals/wireless/>Wireless</a></li></ul></li><li><a href=/docs/interworking/>Interworking</a><ul><li><a href=/docs/interworking/congestion/>Congestion</a></li><li><a href=/docs/interworking/presentation-and-compression/>Presentation & Compression</a></li><li><a href=/docs/interworking/routing/>Routing</a></li><li><a href=/docs/interworking/scaling-networks/>Scaling Networks</a></li></ul></li><li><a href=/docs/protocols/>Protocols</a><ul><li><a href=/docs/protocols/rpc/>RPC</a></li><li><a href=/docs/protocols/rtp/>RTP</a></li><li><a href=/docs/protocols/tcp/>TCP</a></li><li><a href=/docs/protocols/udp/>UDP</a></li></ul></li><li><a href=/docs/applications/>Applications</a><ul><li><a href=/docs/applications/dns/>DNS</a></li><li><a href=/docs/applications/sdp-and-sip/>SDP & SIP</a></li><li><a href=/docs/applications/smtp/>SMTP</a></li><li><a href=/docs/applications/snmp/>SNMP</a></li><li><a href=/docs/applications/soap-and-rest/>SOAP & REST</a></li></ul></li><li><a href=/docs/privacy-and-security/>Privacy & Security</a><ul><li><a href=/docs/privacy-and-security/anonymity-and-privacy/>Anonymity & Privacy</a></li><li><a href=/docs/privacy-and-security/network-security/>Network Security</a></li></ul></li><li><a href=/docs/other/>Other</a><ul><li><a href=/docs/other/overlay-networks/>Overlay Networks</a></li><li><a href=/docs/other/future-of-the-internet/>The Future of the Internet</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Transmission</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#clock-recovery>Clock recovery</a></li><li><a href=#scheme-1---nrz>Scheme 1 - NRZ</a></li><li><a href=#scheme-1---nrzi>Scheme 1 - NRZI</a></li><li><a href=#manchester-encoding>Manchester Encoding</a></li><li><a href=#4b5b>4B/5B</a></li></ul><ul><li><a href=#parity>Parity</a></li><li><a href=#check-sums>Check Sums</a></li><li><a href=#crc---cyclic-redundancy-check>CRC - cyclic redundancy check</a></li></ul><ul><li><a href=#stop-and-wait>Stop and Wait</a></li><li><a href=#sliding-window>Sliding Window</a></li></ul></nav></aside></header><article class=markdown><h1 id=transmission>Transmission
<a class=anchor href=#transmission>#</a></h1><h1 id=encoding>Encoding
<a class=anchor href=#encoding>#</a></h1><p>First of all, the physical layer transmits signals, not bits. So we need to translate back and forth. This is done via modulation and demodulation.</p><h2 id=clock-recovery>Clock recovery
<a class=anchor href=#clock-recovery>#</a></h2><p>Clock recovery means being able to recover and deduce the senders clock, since the sender sends information triggered by clock cycles.</p><p>Intuitively, clock recovery is easier by sending frequent <code>0-1</code> and <code>1-0</code> transmissions.</p><h2 id=scheme-1---nrz>Scheme 1 - NRZ
<a class=anchor href=#scheme-1---nrz>#</a></h2><p>The simplest scheme.</p><p>Bit <code>1</code> may be sent as a high voltage signal and bit <code>0</code> as a low one.</p><p>NRZ = Non-Return to Zero.</p><p>Main issue is that consecutive identical voltages are hard to distinguish by the receiver. For example, cannot distinguish a zero from no signal and too many consecutive ones cause the baseline signal to deviate from the true average.</p><h2 id=scheme-1---nrzi>Scheme 1 - NRZI
<a class=anchor href=#scheme-1---nrzi>#</a></h2><p>NRZI = Non-Return to Zero Inverted.</p><p>Here the sender stays the same to signal a zero and changes to signal a 1. Does not solve the consecutive zeros problem, but does solve the consecutive 1s problem.</p><h2 id=manchester-encoding>Manchester Encoding
<a class=anchor href=#manchester-encoding>#</a></h2><p>The sender transitions from low to high in order to encode a <code>0</code>, and a high to low transition to encode a <code>1</code>. Ensures transmission on every bit so clock recovery is easy. The problem is that it is somewhat inefficient because it requires that more bits be transmitted than those in the original signal.</p><h2 id=4b5b>4B/5B
<a class=anchor href=#4b5b>#</a></h2><p>Solves the inefficiency of Manchester encoding by converting every sequence of 4 bits to 5, and encodes the four bits in NRZI. This way no consecutive sequence of 3 or more zeros to ever appear.</p><h1 id=framing>Framing
<a class=anchor href=#framing>#</a></h1><p>Assuming that we solved encoding, now we are concerned with sending really big files across.</p><p>One way is just a bit or byte stream and continually send bits/bytes across.</p><p>Another approach would be to “packetize” or make frames of smaller sizes and ship them across. This is <em>framing</em>.</p><p>Examples of framing protocols:</p><ul><li>PPP, point-to-point protocol. byte oriented.</li><li>And HDLC, high-level data link control. bit oriented.</li><li>SONET, clock-based framing.</li></ul><p>The idea is that the sender demarcates the sequence of bits with a BEGIN marker, (<code>01111110</code> in the case of HLDC) and the bits in between correspond to a frame.</p><p>The link layer sends the frame via one of the modulation methods, and then at the receiver, the link layer delivers them to the app that request it.</p><p>Each protocol has a</p><ul><li>peer interface</li><li>and a service interface.</li></ul><p>Service interface is how objects on the same computer interact with it.</p><p>A peer interface is how to talk to other machines</p><h1 id=error-detection>Error Detection
<a class=anchor href=#error-detection>#</a></h1><h2 id=parity>Parity
<a class=anchor href=#parity>#</a></h2><p>A parity bit, or check bit, is a bit added to a string of binary code.</p><p>Accordingly, there are two variants of parity bits: <strong>even parity</strong> and <strong>odd parity</strong>.</p><p>Even parity → for a given set of bits, the bits whose value is 1 are counted.</p><p>If that count is odd, the parity bit value is set to 1, making the total count of occurrences of 1s in the whole set (including the parity bit) an even number.</p><p>If even, set to 0.</p><p>2D Parity does this for 6 bytes, then has a parity byte.</p><p>where the <code>ith</code> bit is the parity of the <code>ith</code> column created by the <code>ith</code> elements in each previous byte.</p><h2 id=check-sums>Check Sums
<a class=anchor href=#check-sums>#</a></h2><p>Add up all the words that are transmitted and then transmit that sum.</p><h2 id=crc---cyclic-redundancy-check>CRC - cyclic redundancy check
<a class=anchor href=#crc---cyclic-redundancy-check>#</a></h2><p>ah… later</p><h1 id=reliable-transmission-error-correction>Reliable Transmission (error correction)
<a class=anchor href=#reliable-transmission-error-correction>#</a></h1><h2 id=stop-and-wait>Stop and Wait
<a class=anchor href=#stop-and-wait>#</a></h2><p>ARQ (Automatic Repeat reQuest).</p><p>Sender sends a packet (or frame) and waits to receive and ACK before it sends the next packet. Aka the Stop-and-Wait scheme.</p><p>Main draw back is that it only allows for one outstanding packet in each roundtrip time RTT. So it doesn’t “fill the pipe” between send and receiver.</p><h2 id=sliding-window>Sliding Window
<a class=anchor href=#sliding-window>#</a></h2><p>Assuming bandwidth <em>B</em> and RTT <em>d</em>, supposed the quantity if bits we can fit into the “pipe” is <em>P</em>.</p><p>If the pipe is full then B is fully utilized.</p><p>If no data is lost, then at best throughput is <em>P/d</em> for the receiver.</p><p>Pipe size / the round trip time.</p><p>So to utilize bandwidth the right pipe size is, <em>B x d.</em></p><p>This is often called the bandwidth delay product of the network between sender and receiver.</p><p>Ideally the sender want B x d bytes in the pipe before checking what’s been received.</p><p>(unless the size of the packet is too big for that)</p><p>So we can do this with a window based protocol.</p><p>Sending a windows worth of packets and waiting for an ACK for all of them will also sometimes under utilize the pipe, so we actually use sliding window protocols.</p><p>Which means ACK as set as packets are received. Every time an ACK is received, the window slides and is sent again. So data will be sent multiple times, but this is actually the most efficient thing to do because the pipe is always full.</p><p><strong>Exponential Backoff</strong> - if collision is detected, waits and tries again. If collides again, doubles wait time and tries again, over and over again.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#clock-recovery>Clock recovery</a></li><li><a href=#scheme-1---nrz>Scheme 1 - NRZ</a></li><li><a href=#scheme-1---nrzi>Scheme 1 - NRZI</a></li><li><a href=#manchester-encoding>Manchester Encoding</a></li><li><a href=#4b5b>4B/5B</a></li></ul><ul><li><a href=#parity>Parity</a></li><li><a href=#check-sums>Check Sums</a></li><li><a href=#crc---cyclic-redundancy-check>CRC - cyclic redundancy check</a></li></ul><ul><li><a href=#stop-and-wait>Stop and Wait</a></li><li><a href=#sliding-window>Sliding Window</a></li></ul></nav></div></aside></main></body></html>